from multiprocessing import Process, Queue, cpu_count, Pool
import subprocess
import os
import sys
import re
import pefile
import copy

# IDA程序路径
IDAPATH = r'/media/pwd/data/experiment/install/docker/ida/ida-6.4/'
# 样本存储路径
SAMPLES = r'/media/pwd/Elements1/dataset/train/origin_data/'



# 生成IDA脚本调用命令,调用IDA脚本进行asm文件生成
def process_func(path, arch):
    # 选择使用32位还是64位IDA进行解析
    IDAEXE = r"idal"
    if arch == "x64":
        IDAEXE = r"idal64"

    # 根据样本存储路径选择生成对应路径下的IDA返汇编脚本
    if "test_A" in path:
        idcpath = "-S/media/pwd/Elements1/malware_famliy_classfication/ida-ss_test_A.idc"
    elif "test_B" in path:
        idcpath = "-S/media/pwd/Elements1/malware_famliy_classfication/ida-ss_test_B.idc"
    elif "train" in path:
        idcpath = "-S/media/pwd/Elements1/malware_famliy_classfication/ida-ss_train.idc"

    cmds = [IDAPATH + IDAEXE,"-A", "-LlogT", idcpath, path]

    #print(cmds)
    try:
        subprocess.run(cmds, timeout=120)
    except Exception as e:
        print(e)
        
        


def main():
    tasks = []
    cpunum = cpu_count()
    pool = Pool(cpunum)
    # 保证只对文件夹中原始pe文件进行反汇编(运行中会在样本文件夹中生成其他文件.idb,.id0等)
    sample = re.compile(r'[0-9A-Fa-f]{32}$')
    
    for root, dirs, files in os.walk(SAMPLES):
        for name in files:
            if sample.match(name):
                pepath = os.path.join(root, name)
                try:
                    pe = pefile.PE(pepath)
                    # 软件位数判断
                    pearch = "x86"
                    if hex(pe.FILE_HEADER.Machine) != '0x14c':
                        pearch = "x64"
                    tasks.append(pool.apply_async(process_func, args=(pepath, pearch)))
                except Exception as e:
                    tasks.append(pool.apply_async(process_func, args=(pepath, "x86")))
    print("start")
    pool.close()
    pool.join()
    for t in tasks:
        t.get()

main()
